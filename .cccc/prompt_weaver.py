# -*- coding: utf-8 -*-
from pathlib import Path
from typing import Dict, Any, Optional, Tuple

from por_manager import ensure_por, por_path
import json

def _read_yaml_or_json(p: Path) -> Dict[str, Any]:
    try:
        import yaml  # type: ignore
        return yaml.safe_load(p.read_text(encoding="utf-8")) or {}
    except Exception:
        try:
            return json.loads(p.read_text(encoding="utf-8"))
        except Exception:
            return {}

def _rules_dir(home: Path) -> Path:
    d = home / "rules"
    d.mkdir(parents=True, exist_ok=True)
    return d

def _state_dir(home: Path) -> Path:
    d = home / "state"
    d.mkdir(parents=True, exist_ok=True)
    return d

def _calc_rules_hash(home: Path) -> str:
    # Hash a subset of settings that affect rules text
    import hashlib
    parts: list[str] = []
    for name in [
        "settings/cli_profiles.yaml",
        "settings/governance.yaml",
        "settings/coach_helper.yaml",
        "settings/telegram.yaml",
        "settings/slack.yaml",
        "settings/discord.yaml",
    ]:
        fp = home / name
        if fp.exists():
            try:
                parts.append(fp.read_text(encoding="utf-8"))
            except Exception:
                pass
    payload = "\n".join(parts) + "\nGEN:1"  # bump suffix to invalidate older generations
    return hashlib.sha1(payload.encode("utf-8", errors="replace")).hexdigest()

def _is_im_enabled(home: Path) -> bool:
    # Consider IM enabled when any configured bridge has a plausible token/config
    def _has_token(d: Dict[str, Any], keys: Tuple[str, ...]) -> bool:
        for k in keys:
            v = d.get(k)
            if isinstance(v, str) and v.strip():
                return True
        return False

    tg = (home/"settings"/"telegram.yaml")
    if tg.exists():
        d = _read_yaml_or_json(tg)
        if _has_token(d, ("token",)):
            return True
        # Some setups only set autostart with environment token
        if bool(d.get("autostart", False)):
            return True
    sl = (home/"settings"/"slack.yaml")
    if sl.exists():
        d = _read_yaml_or_json(sl)
        if _has_token(d, ("app_token", "bot_token")):
            return True
    dc = (home/"settings"/"discord.yaml")
    if dc.exists():
        d = _read_yaml_or_json(dc)
        if _has_token(d, ("bot_token",)):
            return True
    return False

def _coach_mode(home: Path) -> str:
    cf = home/"settings"/"coach_helper.yaml"
    if not cf.exists():
        return "off"
    d = _read_yaml_or_json(cf)
    t = d.get("triggers") if isinstance(d.get("triggers"), dict) else {}
    mode = str(t.get("mode") or "off").lower().strip()
    if mode in ("off", "manual", "key_nodes"):
        return mode
    if mode == "on":
        return "key_nodes"
    return "off"

def _conversation_reset(home: Path) -> Tuple[str, Optional[int]]:
    gv = home/"settings"/"governance.yaml"
    if not gv.exists():
        return "compact", None
    d = _read_yaml_or_json(gv)
    c = d.get("conversation") if isinstance(d.get("conversation"), dict) else {}
    r = c.get("reset") if isinstance(c.get("reset"), dict) else {}
    policy = str(r.get("policy") or "compact").lower().strip()
    if policy not in ("compact", "clear"):
        policy = "compact"
    try:
        interval = int(r.get("interval_handoffs") or 0)
    except Exception:
        interval = 0
    return policy, (interval if interval > 0 else None)

def _write_rules_for_peer(home: Path, peer: str) -> Path:
    # Gather dynamic switches
    im_enabled = _is_im_enabled(home)
    coach = _coach_mode(home)
    reset_policy, reset_interval = _conversation_reset(home)
    # Paths
    base = f".cccc/mailbox/{peer}"
    to_user = f"{base}/to_user.md"
    to_peer = f"{base}/to_peer.md"
    patchf  = f"{base}/patch.diff"
    por_file = por_path(home)
    por_rel = por_file.as_posix()
    # Role bits
    is_peera = (peer.lower() == "peera" or peer == "peerA")
    role_name = "PeerA" if is_peera else "PeerB"
    other = "PeerB" if is_peera else "PeerA"
    to_user_line = (f"• To user:   write plain text to {to_user} (overwrite whole file; do NOT append)"
                    if is_peera else
                    "• To user:   (disabled for this peer; orchestrator ignores it)")
    # Compose text (English, concise)
    lines: list[str] = []
    lines.append(f"# {role_name} Rules (Generated)\n")
    lines.append(f"Generated by orchestrator. You are {role_name}. Collaborate with {other}.\n")
    lines.append("## Core Principles")
    lines.append("- Evidence-first; chat never changes state.")
    lines.append("- Small, reversible diffs (≤150 lines).")
    lines.append("- End every message with one fenced ```insight block.")
    lines.append("")
    lines.append("## Mailbox Contract")
    lines.append(to_user_line)
    lines.append(f"• To peer:   write plain text to {to_peer} (overwrite whole file; do NOT append)")
    lines.append(f"• Patch:     write unified diff only to {patchf}; keep changes small and reversible")
    lines.append("• Encoding: UTF‑8 (no BOM). Update files by overwriting them, never creating new ones with different encodings.")
    lines.append("")
    lines.append("## POR (Plan-of-Record)")
    lines.append(f"- Single source of direction: {por_rel}")
    lines.append("- Read/maintain at self-check or when direction changes by emitting a patch diff.")
    lines.append("")
    # IM — include only when enabled
    if im_enabled:
        lines.append("## IM Commands (enabled)")
        lines.append("- Route: `a: …`, `b: …`, `both: …` or `/a`, `/b`, `/both`. ")
        lines.append("- Focus: `/focus [hint]` requests POR refresh (PeerB acts).")
        lines.append("- Reset: `/reset compact|clear` (compact preferred).")
        lines.append("- Coach: `/coach status` or `/coach remind off|manual|key_nodes`.")
        lines.append("- Review: `/review` triggers coach reminder.")
        lines.append("- Passthrough: `a! <command>` / `b! <command>` sends raw CLI input to a peer.")
        lines.append("")
    # Coach — include only when not off
    if coach != "off":
        lines.append("## Third-Party Coach (Full Agent)")
        lines.append(f"- Mode: {coach}. Acts as an on-demand helper (no long-lived session).")
        lines.append("- Capabilities: investigate, create files under .cccc/work/**, and write a diff.")
        if is_peera:
            lines.append("- Patch authority: the coach MAY directly write a unified diff to .cccc/mailbox/peerA/patch.diff when invoked by PeerA.")
        else:
            lines.append("- Patch authority: the coach MAY directly write a unified diff to .cccc/mailbox/peerB/patch.diff when invoked by PeerB.")
        lines.append("- Responsibility: you still review/iterate on the coach's output like any peer evidence.")
        lines.append("- If unavailable/timeout: proceed with baseline workflow and note it.")
        lines.append("")
        lines.append("### Coach Non-interactive CLI Examples (Gemini)")
        lines.append("```")
        lines.append("gemini -p \"Write a Python function\"")
        lines.append("echo \"Write fizzbuzz in Python\" | gemini")
        lines.append("gemini -p \"@gemini-test/fibonacci.py Explain this code\"")
        lines.append("")
        lines.append("# Multiple files")
        lines.append("gemini -p \"@package.json @src/index.js Check dependencies\"")
        lines.append("")
        lines.append("# Whole project")
        lines.append("gemini -p \"@project/ Summarize the system\"")
        lines.append("```")
        lines.append("")
    # Reset policy excerpt
    lines.append("## Context Hygiene")
    if reset_policy == "compact":
        lines.append("- Reset policy: compact (periodically condense context; prefer continuity).")
    else:
        lines.append("- Reset policy: clear (fresh start when requested).")
    if reset_interval:
        lines.append(f"- Auto-compact cadence: every ~{reset_interval} handoffs (effective).")
    lines.append("")
    # Role nuances
    lines.append("## Role Nuances")
    if is_peera:
        lines.append("- PeerA may speak to user (to_user.md). Lead framing, acceptance, and decisions.")
    else:
        lines.append("- PeerB must not write to user; focus on implementation, tests, and concise evidence.")
    lines.append("- Use PCR+Hook in to_peer.md; propose one smallest decisive next step (≤10m).")
    lines.append("")
    # Final hint
    lines.append("## When In Doubt")
    lines.append("- Re-read this file and the POR. Cite the clause you follow in your insight refs.")
    lines.append("")

    out = "\n".join(lines)
    rules_dir = _rules_dir(home)
    target = rules_dir/("PEERA.md" if is_peera else "PEERB.md")
    target.write_text(out, encoding="utf-8")
    return target

def ensure_rules_docs(home: Path):
    # Generate rules if missing or when config hash changed
    h = _calc_rules_hash(home)
    state = _state_dir(home)
    stamp = state/"rules_hash.json"
    old = {}
    try:
        old = json.loads(stamp.read_text(encoding="utf-8"))
    except Exception:
        old = {}
    if not (home/"rules"/"PEERA.md").exists() or not (home/"rules"/"PEERB.md").exists() or old.get("hash") != h:
        ensure_por(home)  # make sure POR exists for path rendering
        _write_rules_for_peer(home, "peerA")
        _write_rules_for_peer(home, "peerB")
        try:
            stamp.write_text(json.dumps({"hash": h}, ensure_ascii=False), encoding="utf-8")
        except Exception:
            pass


def _ensure_str(value: Any) -> str:
    if value is None:
        return ""
    if isinstance(value, str):
        return value.strip()
    return str(value).strip()


def weave_system_prompt(home: Path, peer: str, por: Optional[Dict[str, Any]] = None) -> str:
    """Minimal SYSTEM: role, POR, rules path — no duplication."""
    peer = (peer or "peerA").strip()
    try:
        ensure_rules_docs(home)
    except Exception:
        pass
    por_file = por_path(home)
    rules_path = (home/"rules"/("PEERA.md" if (peer.lower()=="peera" or peer=="peerA") else "PEERB.md")).as_posix()
    other = "peerB" if (peer.lower()=="peera" or peer=="peerA") else "peerA"
    return "\n".join([
        "CCCC Runtime SYSTEM (minimal)",
        f"• You are {peer}. Collaborate as equals with {other}.",
        f"• POR: {por_file.as_posix()} (single source; update via patch when direction changes).",
        f"• Rules: {rules_path} — follow this document; keep <TO_USER>/<TO_PEER> wrappers; end with exactly one fenced insight block.",
        "",
    ])


def weave_preamble(home: Path, peer: str, por: Optional[Dict[str, Any]] = None) -> str:
    """
    Preamble text used for the first user message — identical source as SYSTEM
    to ensure single-source truth. By default returns weave_system_prompt.
    """
    return weave_system_prompt(home, peer, por)
