# CCCC v0.4.0 Release Notes

**A lightweight multi-agent framework with infrastructure-grade reliability.**

Chat-native, prompt-driven, and bi-directional by design.

`v0.4.0` is the first stable release of the new CCCC generation.
Compared to `v0.3` (the tmux-first line in [cccc-tmux](https://github.com/ChesterRa/cccc-tmux)), this is a ground-up redesign focused on real production workflows, not terminal tricks.

## What Actually Changed in v0.4.0

### 1) Chat-native orchestration: assign work like talking to teammates

v0.4 introduces a full Web control plane where multi-agent coordination happens in a chat flow:

- assign tasks in the conversation, not through fragmented shell rituals
- track delivery/read/ack/reply status as workflow state
- manage agents, group state, and automation from the same workspace

This is not just a UI layer.
It changes the operating model from “operator drives terminals” to “operator drives collaboration state.”

In addition, CCCC supports external IM bridges (Telegram, Slack, Discord, Feishu/Lark, DingTalk), so the same collaboration model can extend beyond the browser when teams are on the move.

### 2) Workflow-by-design: prompt-configured multi-agent execution

v0.4 treats workflow design as a first-class capability:

- guidance prompts define how agents collaborate, escalate, and report
- automation rules handle recurring, one-time, and interval triggers
- typed actions (`notify`, `group_state`, `actor_control`) make behavior explicit and composable

The key shift is flexibility with control:
teams can build very different multi-agent operating styles without forking the core system.

### 3) Bi-directional orchestration: CCCC schedules agents, agents can schedule CCCC

v0.4 establishes a two-way control architecture:

- CCCC orchestrates runtimes, routing, delivery obligations, and lifecycle
- agents can actively manage workflows through MCP tools (messaging, automation, group actions)

This unlocks a new class of workflows:
agents are no longer passive executors; they can become active operators that create, tune, and run automation loops safely inside system boundaries.

## Why This Is a Major Version Shift (Not a Feature Bump)

### Daemon-first system core

All ports (Web/CLI/MCP/IM) are now thin interfaces over one daemon authority.
This removes split-brain behavior and keeps cross-interface semantics consistent.

### Append-only ledger as source of truth

Each group persists an auditable event history (`groups/<group_id>/ledger.jsonl`), enabling replay, incident review, and reliable recovery.

### Accountable messaging semantics

Read cursors, acknowledgements, and reply-required obligations make communication operationally enforceable, not best-effort chat noise.

## Practical Impact for Teams

With v0.4, teams can run long-lived multi-agent operations with:

- clearer task assignment and follow-up
- stronger delivery accountability
- lower coordination overhead in daily execution
- higher confidence in recovery and debugging

## Migration Notes from v0.3

Treat v0.4 as a new generation:

1. Clean old v0.3 runtime residue.
2. Re-initialize groups under the v0.4 model (`CCCC_HOME`, default `~/.cccc/`).
3. Reconnect runtimes via `cccc setup --runtime <runtime>`.
4. Run `cccc doctor` before production rollout.

## Closing

v0.4.0 turns CCCC into a complete multi-agent collaboration system:

- chat-native control
- prompt-driven workflow design
- bi-directional orchestration between platform and agents

This is the release where CCCC moves from “interesting tooling” to “operable infrastructure.”
